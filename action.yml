name: "Build WASM Runtime"
description: "Build WASM Runtime with SRTOOL"
author: chevdor
branding:
  icon: "package"
  color: "blue"

inputs:
  tag:
    description: "Tag of the srtool image to use"
    default: "nightly-2021-03-15"
    required: true
  image:
    description: "You can use an alternate image, use with caution!"
    required: true
    default: "chevdor/srtool"
  workdir:
    description: "Path of the project, this is where your main Cargo.toml is located"
    required: true
  chain:
    description: "Name of the chain, ie. polkadot"
    required: true
  package:
    description: "Runtime package to build, ie. polkadot-runtime"
    required: true
  build_dir:
    description: "Location of the runtime in your repo"
    required: true
outputs:
  # runtime:
  #   description: "The generated Runtime"
  #   value: "the runtime"
  proposal_hash:
    description: "The proposal hash as it will show on-chain"
    value: ${{ steps.build.outputs.proposal_hash }}
  json:
    description: The json output of srtool
    value: ${{ steps.build.outputs.build }}
  version:
    description: The version of srtool
    value: ${{ steps.build.outputs.version }}
  info:
    description: Some information from srtool about the current project
    value: ${{ steps.build.outputs.info }}
  ipfs_hash:
    description: ipfs hash
    value: ${{ steps.build.outputs.ipfs_hash }}
  wasm_path:
    description: Path of the produced runtime
    value: ${{ steps.build.outputs.wasm_path }}

runs:
  using: "composite"
  steps:
    - id: version
      shell: bash
      run: |
        # using working-directory would be nicer but act seems to be full of bugs...
        cd ${{ inputs.workdir }} 
        echo "::debug::version"
        CMD="docker run -i --rm -v $PWD:/build ${{ inputs.image }}:${{ inputs.tag }} /srtool/version -cM"
        JSON=`$CMD`
        echo "::set-output name=version::$JSON"

    - id: info
      shell: bash
      run: |
        cd ${{ inputs.workdir }} 
        echo "::debug::info"
        echo "::debug::info::git" `ls -ald ${{ inputs.workdir }}/.git`
        echo "::debug::info::cargo" `ls -al ${{ inputs.workdir }}/Cargo.toml`
        CMD="docker run -i --rm -v ${{ inputs.workdir }}:/build ${{ inputs.image }}:${{ inputs.tag }} /srtool/info -cM"
        JSON=`$CMD`
        echo "::set-output name=info::$JSON"

    # - id: checks
    #   name: Build ${{ inputs.package }} using ${{ inputs.image }}:${{ inputs.tag }}
    #   shell: bash
    #   run: |
    #     echo "::debug::checks"
    #     cd ${{ inputs.workdir }}
    #     echo "::debug::checks::pwd" `pwd`
    #     echo "::debug::checks::workdir" ${{ inputs.workdir }}
    #     # ls -al
    #     docker run -i --rm -v ${{ inputs.workdir }}:/build busybox ls /build/Cargo.toml

    - id: build
      name: Build ${{ inputs.package }} using ${{ inputs.image }}:${{ inputs.tag }}
      shell: bash
      env:
        RUNTIME_DIR: runtime/${{ inputs.chain }}
      run: |
        cd ${{ inputs.workdir }}
        echo "::debug::build::workdir" ${{ inputs.workdir }}
        echo "::debug::build::chain" ${{ inputs.chain }}
        echo "::debug::build::runtime_dir" $RUNTIME_DIR

        CMD="docker run -i --rm -e PACKAGE=${{ inputs.package }} -e RUNTIME_DIR=$RUNTIME_DIR -v ${{ inputs.workdir }}:/build ${{ inputs.image }}:${{ inputs.tag }} /srtool/build --app --json -cM"
        # here we keep streaming the progress and fetch the last line for the json result
        stdbuf -oL $CMD | {
          while IFS= read -r line
          do
            echo "::debug::srtool $line"
            JSON="$line"
          done
          echo "::set-output name=json::$JSON"
          PROP=`echo $JSON | jq -r .prop`
          echo "::set-output name=proposal_hash::$PROP"
        }
